<!--2)Способы 2-ч сторонего связывания input -->

<!--<template>
  <div>
      <input 
      type="text"
      v-model="inputValue">
  </div>
</template>

<script>
export default {
data() {
    return {
        inputValue:''
    }
}
}
</script>

<style>

</style>
-->

<!-- 3)Что такое props
Определение Props - пользовательские параметры, 
атрибуты , который может принимать компонент
с помощью props  мы можем ипользовать компонентынй подход,
передавать данные из родительских копонентов в дочерние
 -->

 <!-- 4) Как работает рекативность во Vue
Реактивность vUE -  МЫ ИЗМЕНИЛИ КАКЕИ ТО ДАННЫЕ В КОДЫ,
И СРАЗУ УВИДИЛИ ИЗМЕНЕНИЯ НА СТРАНИЦЕ
 -->

<!--<template>
  <div>
      Колличество лайков = {{likes}}
  </div>
  <button @click="likes += 1">Поставить лайк </button>
</template>

<script>
import { computed } from '@vue/runtime-core'
export default {
 data() {
     return {
        likes: 0
     }
   }
 }
</script>
-->

 <!-- 5) Что такое Composition API  во Vue
 позволяет хранить реактивные данные отдельно от компонентовБ
 что позволит создавать  рекативные куски кода и делать,
 это более гибко чем mixins
 -->


 <!-- 6) Особенности использования v-model Vue 3 and Vue 2
 Vue 2 используеться всего 1 v-model и по умолчанию у него 
 значение value и прослушивать событие котрое по умолчанию onInput
 /////////////////////////////////////////////////////////
 Для того чтобы модель  изменять, должен имитить события input
 this.$emit (input)

 Vue 3 можем использовать огромное колличество  v-model
 Для того чтобы изменять значение, которое задаеться по шаблону
 this.$emit (update:title)
 -->


 <!-- 7) для чего нужен $emit

 -->

  <!-- 8) Постраничная навигация во Vue
  Навигацию во Vue  можно создать спомощью библиотеки Vue-router
   с помощью мы можем указать новый router,  внутри котрого указываем массив 
   маршрутов, при этом для каждого компонента указываем
   путь и компонент, который по этому пути должен отрисовываться.<template>
     После чего мы  мы этот app.use(router) регистрируем ,
     и для того чтобы монтировать компонент, который отрисовываеться по определнному пути 
     используеться компонент <router-view/>. 
     А для постраничной нгавигации мы используем тег <router-link/>
     -->

 <!-- 9) что такое computed свойства и как они работают.
Computed свойства позоляет закешировать результат вычислений,
и эти вычисления повторяться вновь в том случае, если изменилась какя та 
модель внутри computed  свойства

-->
<!--<template>
  <div>
      <h1>Счетчик = {{counter}}</h1>
      <button @click="counter++">Увеличить счетчик </button>

      <h1>Колличество этапов в массиве  = {{doubleLength}}</h1>
      <button @click="list.push(list.length +1)">УДобавить массив </button>
      <div :key="item" v-for="item in list">{{item}}</div>
  </div>
</template>

<script>
export default {
 data() {
     return {
         counter: 0,
         list:[1, 2]
    }
  },
computed: {
    doubleLength() {
        console.log('ВЫЗВАНА')
         return this.counter.length *2
    }
  }
}
</script>
-->

 <!-- 10) Как отследить изменения модели
  Для этого во Vue  используються WATCH

-->

<!--<template>
 <div>
      <h1>Счетчик = {{counter}}</h1>
      <button @click="counter++">Увеличить счетчик </button>

  </div>
</template>

<script>
export default {
 data() {
     return {
         counter: 0,
    }
  },
  watch: {
      counter(newValue) {
          console.log('Изменение counter' + newValue)
      }
    }
  }
</script>
-->

 <!-- 11) Как сделать глубокое отслеживание 
 По  default глубокое отслеживание не производиться 
 Чтобы сделать глубокое отслеживание, мы создаем одноименое поле 
 user,  внутри указываем hendler,  котрый будет отрабатывать на изменение 
 модели, также добавляем поле deep  со значением true

-->
<!--<template>
  <div>
      <input 
      type="text"
      v-model="user.address.street"
    >
  </div>
</template>

<script>
export default {
 data() {
     return {
         user: {
             name: 'Ulbi tv',
             address: {
                 street:''
        }
      }
    }
 },
watch: {
    user: {
      handler(newValue) {
        console.log(newValue)
      },
      deep:true
     }
   }
 }
</script>
-->

 <!-- 12) Что такое интерполяция 
 Определение - это форма привязки позволяющая в шаблон выводить
 какие то данные 
-->


 <!-- 12) Как отрисовать компонент по условию
Для это во Vue  предусмотрены v-if and v-else
-->


<!--
<template>
 <div>
      <h1>Счетчик = {{counter}}</h1>
      <button @click="counter++">Увеличить счетчик </button>
    
     <div v-if="counter < 4">Блок 1</div>
     <div v-else-if="counter < 5">Блок 2</div>
     <div v-else>Блок 3</div>
  </div>
</template>

<script>
export default {
 data() {
     return {
         counter: 0,
    }
  },
  watch: {
      counter(newValue) {
          console.log('Изменение counter' + newValue)
      }
    }
  }
</script>
-->

 <!-- 14) Разница между v-if and v-show
  1) Когда мы используем v-show мы не можем использовать 
  v-else, а значит для каждого блока надо прописывать
  свое условие 

  2) В ОТЛИЧИЕ от V-if V-show не удаляет обьект в DOM-дереве
  а ставит значение display:none
  V-if свою очередь удаляет обьект полностью из DOM-дерева когда
  условие не соблюденно
-->

 <!-- 15) Что такое миксины и как их использовать
 Mixin  объединяеться в компонент и позволяет  и добавлять этот 
 КОМПОНЕНТ НОВЫЙ ФУНКЦИОНАЛ
-->

<!--
<template>
 <div>
      <h1>Счетчик = {{counter}}</h1>
      <button @click="increment">Увеличить счетчик </button>

  </div>
</template>

<script>
import counterMixin from "@/components/counterMixin"
export default {
 mixins: [counterMixin]
  }
</script>
-->

 <!-- 16) Что такое ДИРЕКТИВЫ
 Оперделение - специальные атрибуты которые мы можем 
 использовать внутри html шаблона.
 Директивы позволюбт добавить функциональность  и сократить
 колличество кода.
-->


 <!-- 17) Как создать пользовательскую директиву
          Особенности использования 
          
-->
<!--
 <template>
 <div>
      <h1>Счетчик = {{counter}}</h1>
      <div 
      style="max-height: 100vh;  overflow: scroll" 
      v-scroll="increment" >
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
        Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.
      </div>
  </div>
</template>

<script>

export default {
     data() {
         return {
             counter: 0
        }
    },
    methods: {
        increment() {
            this.counter += 1
        }
    }
}
</script>
-->

 <!-- 18) рАССКАЖИТЕ О ЖИЗНЕНОМ ЦИКЛЕ КОМПОНЕНТА vUE
   Жизненный цикл можно поделить на несколько этапов:
   1) Инициализация - инициализируються события  и сам 
   жизненный цикл, при этом за всем жизненным циклом,
   мы можем следить с помощью hook вызываеться на этом этапе 
   beforeCreate

   2) Инициализация реактивности и некотрых инъекций
   Вызываеться hook created

   3)После чего идет монтироваение компонентов 
    Вызываться два hook : beforeMount
                          mounted
    На этом этапе рекомендуеться делать запросы  серверу
    первичную инициализацию. поскольку компонент 
    готов уже к использованию

    4)Обновление компонентов, за которым мы 
    также можем следитьБ вызываеться два hook
      :beforeUpdate
      :updated

    5)Демонтирования компонента. Га данном этапе 
    компонент демонтируеться из DOM-дерева
    и вызываються 2 hook
     :beforeUnmount
     :unmounted  рекомендуеться удалять 
     слушателей события, делать очистку
-->

 <!-- 19) В каком методе жц необходимо делать первичную загрузку 
   данных с сервера.
   Для этого предназначен mounted() {
       this.fetchData()
   }
-->

 <!-- 20) В каком методе жц необходимо делать 
 очистку(удалять слушателя, очишать хранилище) 
   данных с сервера.
   Для этого предназначен 
   unmounted() {
       this.resetState()
       this.removeListeners()
   }
  вызываеться в тот момент когда компонент был демонтирован

   -->


 <!-- 21) Как сделать стили локальными для компонента
   <style scoped>
   .post {
       margin: 10px
   }
   </style>>
   -->

    <!-- 22) Как отрисовать несколько компонентов 
       на  основе массива
       используем директиву v-for
       -->

    <!-- 23) Для чего импользуется key

    key нужен для подсказки vue и для его вритуального DOM объекта
    Чтобы сравнить измененный список с обновленными элементами
    и сделать отрисовку()перерендеринг) только тех участков., 
    которые действительно изменились
    Рекомендуеться брать id из объекта 

    -->

 <!-- 24) Как ОТСЛЕДИТЬ ИЗМЕНЕНИЕ ПОЛЯ ОБЪЕКТА 

 WFTCH: {
     USER.ADDRESS.STREET(NEWValue)
     console.log(newValue)
 }
 -->

 <!-- 25) Как добавить слушатель события на элемент 
  <input v-on:click=''> либо краткая запись
  @click
  -->    
  
  <!-- 26) Что такое модификаторы 
  Определение -  модификаторы - это дополнение для директивы
  котрое позволяе изменить поведение этой директивы
  Чаще всего используеться для v-model и  v-on
  -->

  <!-- 27) Какие модификаторы есть у событий 
   stop, prevent, once 
   -->

     <!-- 28) Какие модификаторы есть у v-model
     3 модификатора 
     -->

  <!-- 29) Как добавить анимацию на удаление /добавление 
  элемента в список
  -->


  <!--
  <template>
 <div>
   <button @click="list.push(list.length + 1)">Добавить</button>
    <transition-group name="list" tag="div">
      <div v-for="item in list" :key="item" class="item">
       {{item}}
      </div>
    </transition-group>
  </div>
</template>

<script>

export default {
     data() {
         return {
             list:[1,2,3,4]
        }
    }
}
</script>

<style >
.list-item {
  display: inline-block;
  margin-right: 10px;
}
.list-enter-active,
.list-leave-active {
  transition: all 1s ease;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(130px);
}
</style>
-->

  <!-- 30) Как зарегать компонент Vue 3 глобально
  необходимо вызвать функцию компонент
  app.component(my-component, Component)
  -->

    <!-- 31) Как передать данные из родительского компонента 
    в дочерний не используя props и  store

    -->

  <!-- 32) Как использовать класс по условию


  -->

  <!--
   <template>
 <div :class="{green: toggle}" class="height100">
   <button @click="toggle =!toggle">Изменить цвет</button>
  </div>
</template>

<script>

export default {
     data() {
         return {
         toggle: false
        }
    }
}
</script>

<style >
.height100 {
  height: 100vh;
  margin-right: 10px;
}
.green {
    background-color: green;
}

</style>
 -->

  <!-- 33) Как динамически изменять стили у элемента 

  -->

<!--
   <template>
 <div :style="{backgroundColor: color}" class="height100">
   <button @click="toggle">Изменить цвет</button>
  </div>
</template>

<script>

export default {
     data() {
         return {
            color: 'red'
        }
    },
    methods: {
        toggle() {
          this.color =  this.color === 'red' ? 'green' : 'red';
        }
    }
}
</script>

<style >
.height100 {
  height: 100vh;
  margin-right: 10px;
}
.green {
    background-color: green;
}

</style>
-->

  <!-- 34) Расскажите о слотах во Vue

-->
<!--
<template>
  <div>
      <card>
      <template v-slot:header>Заголовок карточки</template>
      <template v-slot:body>Тело карточки</template>
      <template v-slot:actions>
          <button>Принять</button>
          <button>Отменить</button>
      </template>
      </card>
  </div>
</template>

<script>
import Card from '@/components/Card.vue';
export default {
  components: { Card },

}
</script>

<style>

</style>
-->

  <!-- 35) Каким пособом можно получить доступ DOM элементом 
     во Vue
-->
<!--
<template>
  <div>
      <input ref="inputref" type="text">
      <button @click="getRef">Get element</button>
  </div>
</template>

<script>
export default {
   methods: {
       getRef() {
           this.$refs.inputref.focus()
           console.log(this.$refs.inputref)
       }
   }
}
</script>

<style>

</style>
-->

  <!-- 36) Предназначение Keep-alive в Vue
-->

<!--
<template>
  <button @click="currentComponent = 'FirstComponent'">First</button>
  <button @click="currentComponent = 'SecondComponent'">Second</button>
    <keep-alive>
      <component :is="currentComponent"></component>
    </keep-alive>
</template>

<script>
import SecondComponent from "@/components/SecondComponent.vue" 
import FirstComponent from "@/components/FirstComponent.vue" 

export default {
  components: {SecondComponent,FirstComponent},
    data() {
        return {
          currentComponent:  'FirstComponent'
        }
    }
}
</script>

<style>

</style>
-->

  <!-- 37) Зачем нужны телепорты во Vue
  <teleport></teleport>
-->

  <!-- 38) Как подлкючить внешние плагины во VUE
  эТО МОЖНО СДЕЛАТЬ С ПОМОЩЬЮ 
  app.use.(vuex)
-->

  <!-- 39) Как сщхдать собствнный плагин
    export: {
     install:   (app, options) => {
        //код пдагина будет здесь
    }
-->


  <!-- 41) Почему не стоит использовать в качестве 
  ключей(key) индексы элемента массива

  Ответ: Ключ всегда должен связан с элементом масива 
  и не должен изменяться .Это должен быть уникальный ID

  Потомучто при удалении перестановки элемента в массиве
  индекс и элемент с которым он был сопостален  нарушаеться.
  ТО есть 1 индекс уже может относиться совсем к другому элементу
  При этом пропадает эффективность использования ключей
   и алгоритм котрый работает с virtual-DOM РАБОТАЕТ НЕККОРЕКТНО
-->

  <!-- 42) Как подлкючить внешние плагины во VUE
  эТО МОЖНО СДЕЛАТЬ С ПОМОЩЬЮ 
  app.use.(vuex)
-->

<!--
<template>
  <div>
      <button @click="filter">FILTER</button>
      <div v-for="elem in list" :key="elem">
          {{elem}}
      </div>
  </div>
</template>

<script>
export default {
   data() {
       return {
           list: [1,2,3,4,5,6,7,8]
       }
   },
   methods: {
       filter() {
          this.list = this.list.filter(elem => elem & 2 !== 0)
       }
   }
}
</script>

<style>

</style>
-->

  <!-- 43) Можно ли использовать v-if и v-for  в одном элементе 
   Для фильтрации элементов в списке 
   (v-for='user in users' v-if='user.isActive')
   В этих случаях заменить USERS новым вычисляемым свойством
   которое возвращает отфильтрованный список например activeUsers

-->


  <!-- 44) МОЖНО ЛИ ИЗМЕНТЬ COMPUTED СВОЙСТВА?
  Не рекомендуеться изменять. Изменять нужно одну из зависимостей
   котрые  используеться внутри этого свойтсва, или создать новое 
   computed функциюБ котрая будет внутри себя работать с другой 
   computed функцией.
-->

  <!-- 45) Для чего нужен vUEX  ИКАКИЕ ПРОБЛЕМЫ ОН РЕШАЕТ.
  эТО ПАТЕРН ДЛЯ УПРАВЛЕНИЯ СОСТОЯНИЕМ И ОН СЛУЖИТ ЦЕНТРАЛИЗОВАННЫМ 
  ХРАНИЛИЩЕМ ДАННЫХ ДЛЯ ВСЕХ КОМПОНЕНТОВ.
  тО ЕСТЬ МЫ НЕ ПЕРЕДАЕМ ДАННЫЕ ПО ИЕРАРХИЕ СВЕРХУ ВНИЗ. ЕСТЬ НЕКОТРОЕ 
  ГЛОБАЛЬНОЕ ХРАНИЛИЩЕ И ЛЮБОЙ КОМПОНЕНТ МОЖЕТ ПОЛУЧАТЬ ИЗ НЕГО ДАННЫЕ.<template>
    Состояние может быть изменено  с помощью мутаций и экшенов.
-->

  <!-- 46) Расскажите о state и getters во VUEX
  Vuex использует единное дерево состояний, тот случай когда один 
  объект содержит все состояния приложения  и служит единственным 
  источникам истины.то есть у нас только одно хранилище
  STATE ХРАНЯТЬСЯ ДАННЫЕ С КОТОРЫМИ НАМ ПРЕДСТОИТ РАБОТАТЬ 
  GETTERS - COMPUTED СВОЙСТВА КОТОРЫЙ ПРОИЗВОДИТ КАКИЕ ТО ВЫЧИСЛЕНИЯ 
  НАД ДАННЫМИ КОТРЫЕ НАХОДЯТЬСЯ В СОСТОЯНИИ И КЕШИРУЮТ РЕЗУЛЬТАТ 
  ДО СИХ ПОР, ПОКА ОДНА ИЗ ЗАВИСИМОСТЕЙ НЕ ИЗМЕНИТЬСЯ

  -->

  <!-- 47) MUTATIONS AND ACTION  В ЧЕМ ИХ ОТЛИЧИЯ.

    MUTATIONS -ФУНКЦИЯ КОТОРАЯ ВНУТРИ СЕБЯ ИЗМЕНЯЕТ ПОЛЯ ИЗ СОСТОЯНИЯ
    MUTATIONS ПОЗВОЛЯЮТ СДЕЛАТЬ ПРОЦЕСС БОЛЕЕ ПРОЗРАЧНЫМ И ЯВНЫМ
    
    ACTION ПОХОЖЕ НА MUTATIONS, НО ЕСТЬ ОТЛИЧИЯ, ОНА СОДЕРЖИТ 
    В СЕБЕ САЙТ ЭФФЕКТЫ, ТАЙМЕРЫ, ЗАПРОСЫ НА СЕРВЕР, НО ПРИ ЭТОМ 
    ACTION ВЫЗЫВАЮТ ВНУТРИ СЕБЯ  MUTATIONS ДЛЯ ТОГО ЧТОБЫ КАК ТО 
    ИЗМЕНИТЬ СОСТОЯНИЕ.
    MUTATIONS ЯВЛЯЮТЬСЯ СИНХРОНЫМИ И МОГУТ В СЕБЕ СОДЕРЖАТЬ АСИНХРОННУЮ ЛОГИКУ
-->

  <!-- 48) Как использовать STORE ВНУТРИ КОМПОНЕНТА
  пОСЛЕ ТОГО КАК STORE МЫ ГЛОБАЛЬНО ЗАРЕГИСТРИРОВАЛИ В НАШЕМ
  ПРИЛОЖЕНИИ, ВНУТРИ ЛЮБОГО КОМПОНЕНТА МЫ МОЖЕМ ОБРАТИТЬСЯ К НЕМУ
  getFromState () {
      return this.$store
  }
  При этом с помощью специальных методов мы можем вызывать 
  мутацииБ акшены, сторы и использовать геттеры.

  Также во Vuex есть специальные функции котрые позволяют замапить
    computed: {
      mapState
      mapGetters
    }
    method: {
      mapMutations
      mapActions
    }
  
   mapState

-->

  <!-- 49) Как принудительно  обновить компонент во Vue
  -->

  <template>
  <div>
      <h1>{{Math.random() }}</h1>
      <button @click="update">update</button>
  </div>
</template>

<script>
export default {
   methods: {
       update() {
          this.$forceUpdate()
       }
   }
}
</script>

  <!-- 50) Для чего нужны асинхронные компоненты во Vue
  При росте приложения возникает необходимость разделять приложения на меньшие 
  части и загружать компоненты с сервера только тогда когда они 
  нужны. Для этого предназначен метод defineAsyncComponent
  -->

